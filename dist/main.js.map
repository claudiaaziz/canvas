{"version":3,"file":"main.js","mappings":"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","sources":["webpack://canvas-project/./src/scripts/brushHandler.js","webpack://canvas-project/./src/scripts/colorHandler.js","webpack://canvas-project/./src/scripts/drawingHandler.js","webpack://canvas-project/./src/scripts/downloadHandler.js","webpack://canvas-project/./src/scripts/canvasHandler.js","webpack://canvas-project/./src/scripts/toolIcon.js","webpack://canvas-project/./src/index.js"],"sourcesContent":["class BrushHandler {\n  constructor(canvasHandler) {\n    this.canvasHandler = canvasHandler;\n    this.setupBrushSize();\n  }\n\n  setupBrushSize() {\n    this.brushSizeInput = document.getElementById(\"size-slider\");\n    this.brushSizeInput.addEventListener(\"input\", () => this.updateBrushSize());\n    this.currentBrushSize = 5;\n  }\n\n  setBrushStyling(\n    color = this.canvasHandler.colorHandler.currentColor,\n    brushSize = this.currentBrushSize\n  ) {\n    this.canvasHandler.ctx.lineCap = \"round\";\n    this.canvasHandler.ctx.lineWidth = brushSize;\n    this.canvasHandler.ctx.strokeStyle = color;\n  }\n\n  updateBrushSize() {\n    this.currentBrushSize = parseInt(this.brushSizeInput.value);\n    this.setBrushStyling();\n  }\n  // dotted brush, glitter brush?\n}\n\nexport default BrushHandler;\n","class ColorHandler {\n  constructor(canvasHandler) {\n    this.setupColorHandling()\n    this.canvasHandler = canvasHandler\n  }\n\n  setupColorHandling() {\n    this.currentColor = \"black\";\n\n    // if a brush color has been selected..\n    this.brushColorPicker = document.getElementById(\"color-picker\");\n\n    this.brushColorPicker.addEventListener(\"input\", () => {\n      this.currentColor = this.brushColorPicker.value;\n    });\n\n    // if a bg color has been selected..\n    this.bgColorPicker = document.getElementById(\"background-color-picker\");\n    this.bgColorPicker.addEventListener(\n      \"input\",\n      () => {\n        const drawnPaths = this.canvasHandler.drawnPaths\n        const redoStack = this.canvasHandler.redoStack\n        this.canvasHandler.clear()\n        this.canvasHandler.drawnPaths = drawnPaths\n        this.canvasHandler.redoStack = redoStack\n        drawnPaths.forEach((path) => this.canvasHandler.redrawPath(path));\n        this.canvasHandler.canvas.style.backgroundColor = this.bgColorPicker.value;\n      }\n    );\n  }\n}\n\nexport default ColorHandler","class DrawingHandler {\n  constructor(canvasHandler) {\n    this.canvasHandler = canvasHandler;\n    this.setupDrawingEventListeners();\n  }\n\n  setupDrawingEventListeners() {\n    this.canvasHandler.canvas.addEventListener(\"mousedown\", (e) => this.startDrawing(e));\n    this.canvasHandler.canvas.addEventListener(\"mousemove\", (e) => this.draw(e));\n    this.canvasHandler.canvas.addEventListener(\"mouseup\", () => this.stopDrawing());\n    this.canvasHandler.canvas.addEventListener(\"mouseout\", () => this.stopDrawing());\n  }\n\n  // // drawing actions\n  startDrawing(e) {\n    if (!this.isDrawing) {\n      // clear the stacks when a new drawing begins\n      this.currentPath = [];\n      this.redoStack = [];\n      this.isDrawing = true;\n    }\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const canvasMouseX = e.clientX - this.canvasHandler.canvas.offsetLeft;\n    const canvasMouseY = e.clientY - this.canvasHandler.canvas.offsetTop;\n\n    // begin a new path in the canvas ctx & move to initial drawing pos\n    this.canvasHandler.ctx.beginPath();\n\n    // move the brush to the adjusted mouse coordinates\n    this.canvasHandler.ctx.moveTo(canvasMouseX, canvasMouseY);\n\n    // store the starting point in the drawing path\n    this.currentPath.push({\n      x: canvasMouseX,\n      y: canvasMouseY,\n      color: this.canvasHandler.colorHandler.currentColor,\n      brushSize: this.canvasHandler.brushHandler.currentBrushSize,\n    });\n\n    // draw a dot at the starting point\n    this.draw(e);\n  }\n\n  draw(e) {\n    if (!this.isDrawing) return;\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const mouseX = e.clientX - this.canvasHandler.canvas.offsetLeft;\n    const mouseY = e.clientY - this.canvasHandler.canvas.offsetTop;\n\n    // connect the current drawing position to the new position\n    this.canvasHandler.ctx.lineTo(mouseX, mouseY);\n\n    // Set brush styling based on whether eraser or brush is checked\n    const color = this.canvasHandler.eraserCheckbox.checked\n      ? this.canvasHandler.colorHandler.bgColorPicker.value\n      : this.canvasHandler.colorHandler.currentColor;\n\n    this.canvasHandler.brushHandler.setBrushStyling(\n      color,\n      this.canvasHandler.brushHandler.currentBrushSize\n    );\n\n    // draw the line on the canvas\n    this.canvasHandler.ctx.stroke();\n\n    // store the current point in the drawing path\n    this.currentPath.push({\n      x: mouseX,\n      y: mouseY,\n      color: color,\n      brushSize: this.canvasHandler.brushHandler.currentBrushSize,\n    });\n  }\n\n  stopDrawing() {\n    if (this.canvasHandler.eraserCheckbox.checked)\n      this.currentPath.isErase = true;\n    if (this.isDrawing) {\n      this.canvasHandler.drawnPaths.push(this.currentPath); // if currently drawing, save the current path to the stack (for undo feature)\n      this.isDrawing = false;\n    }\n  }\n}\n\nexport default DrawingHandler;\n","class DownloadHandler {\n  constructor(canvasHandler) {\n    this.canvasHandler = canvasHandler;\n    this.setupDownloadBtn()\n  }\n\n  setupDownloadBtn() {\n    this.downloadBtn = document.getElementById(\"download\");\n    this.downloadBtn.addEventListener(\"click\", () => this.download());\n  }\n\n  download() {\n    // create a temp canvas to preserve the background (wo this the bg would be transparent)\n    const tempCanvas = document.createElement(\"canvas\");\n    const tempCtx = tempCanvas.getContext(\"2d\");\n    tempCanvas.width = this.canvasHandler.canvas.width;\n    tempCanvas.height = this.canvasHandler.canvas.height;\n\n    // set the background color on the temp canvas\n    tempCtx.fillStyle = this.canvasHandler.canvas.style.backgroundColor;\n    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n\n    // draw the existing canvas content on top of the background\n    tempCtx.drawImage(this.canvasHandler.canvas, 0, 0);\n\n    // get the data URL of the temp canvas\n    const dataUrl = tempCanvas.toDataURL(\"image/png\");\n\n    // create a link ele for download\n    const link = document.createElement(\"a\");\n    link.href = dataUrl;\n    link.download = \"canvas.png\";\n\n    // trigger the download\n    link.click();\n  }\n}\n\nexport default DownloadHandler;","import BrushHandler from \"./brushHandler\";\nimport ColorHandler from \"./colorHandler\";\nimport DrawingHandler from \"./drawingHandler\";\nimport DownloadHandler from \"./downloadHandler\";\n\nclass CanvasHandler {\n  constructor() {\n    this.setupCanvas();\n    this.setupCanvasProportions();\n    this.setupEraser();\n    this.setupUndoBtn();\n    this.setupRedoBtn();\n    this.setupClearBtn();\n\n    this.drawingHandler = new DrawingHandler(this);\n    this.colorHandler = new ColorHandler(this);\n    this.brushHandler = new BrushHandler(this);\n    this.downloadHandler = new DownloadHandler(this);\n  }\n\n  // setting up the canvas\n  setupCanvas() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.isDrawing = false;\n  }\n\n  setupCanvasProportions() {\n    const topMargin = 100;\n    const bottomMargin = 100;\n\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.top = topMargin + \"px\";\n\n    this.canvas.height = window.innerHeight - topMargin - bottomMargin;\n    this.canvas.width = window.innerWidth;\n  }\n\n  setupClearBtn() {\n    this.clearBtn = document.getElementById(\"clear\");\n    this.clearBtn.addEventListener(\"click\", () => this.clear());\n  }\n\n  setupEraser() {\n    this.eraserCheckbox = document.getElementById(\"eraser\");\n  }\n\n  setupUndoBtn() {\n    this.drawnPaths = [];\n    this.undoBtn = document.getElementById(\"undo\");\n    this.undoBtn.addEventListener(\"click\", () => this.undo());\n  }\n\n  setupRedoBtn() {\n    this.redoStack = [];\n    this.redoBtn = document.getElementById(\"redo\");\n    this.redoBtn.addEventListener(\"click\", () => this.redo());\n  }\n\n  // btn actions\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.style.backgroundColor = \"white\";\n    this.redoStack = [];\n    this.drawnPaths = [];\n  }\n\n  undo() {\n    // if there are paths in the stack\n    if (this.drawnPaths.length > 0) {\n      // clear canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (undo) last drawn path from the stack\n      const undonePath = this.drawnPaths.pop();\n      // push the undone path to redo stack\n      this.drawingHandler.redoStack.push(undonePath);\n\n      // redraw all paths that are still in the stack\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n    }\n  }\n\n  redrawPath(path) {\n    path.forEach((point, idx) => {\n      // if it's the starting point of the path\n      if (idx === 0) {\n        // move to the starting point\n        this.ctx.beginPath();\n        this.ctx.moveTo(point.x, point.y);\n      } else {\n        // draw a line to the next point\n        this.ctx.lineTo(point.x, point.y);\n\n        // set brush styling based on point clr & brush size\n        if (path.isErase) point.color = this.colorHandler.bgColorPicker.value;\n        this.brushHandler.setBrushStyling(point.color, point.brushSize);\n\n        this.ctx.stroke();\n      }\n    });\n  }\n\n  redo() {\n    // if there are paths in the redo stack\n    if (this.drawingHandler.redoStack.length > 0) {\n      // clear canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (redo) last undone path from the redo stack\n      const redonePath = this.drawingHandler.redoStack.pop();\n      // push the redone path to drawnPaths stack\n      this.drawnPaths.push(redonePath);\n\n      // redraw all paths with the correct color\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n    }\n  }\n}\n\nexport default CanvasHandler;\n","class ToolIcon {\n  constructor() {\n    this.brushRadio = document.getElementById(\"brush\");\n    this.eraserRadio = document.getElementById(\"eraser\");\n    this.brushLabel = document.querySelector('label[for=\"brush\"]');\n    this.eraserLabel = document.querySelector('label[for=\"eraser\"]');\n    this.detectChange();\n    this.updateIcon();\n  }\n\n  updateIcon() {\n    // update brush icon based on whether the brush is checked\n    this.brushLabel.querySelector(\"img\").src = this.brushRadio.checked\n      ? \"assets/tab-icon.png\"\n      : \"assets/menu icons/not-active-brush.png\";\n\n    // update eraser icon based on whether the eraser is checked\n    this.eraserLabel.querySelector(\"img\").src = this.eraserRadio.checked\n      ? \"assets/menu icons/active-eraser.png\"\n      : \"assets/menu icons/not-active-eraser.png\";\n  }\n\n  detectChange() {\n    // update icon clr when tool is changed\n    [this.brushRadio, this.eraserRadio].forEach((radio) => {\n      radio.addEventListener(\"change\", () => this.updateIcon());\n    });\n  }\n}\n\nexport default ToolIcon;\n","import CanvasHandler from \"./scripts/canvasHandler\";\nimport ToolIcon from \"./scripts/toolIcon\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new CanvasHandler();\n  new ToolIcon();\n});\n\n\n\n\n\n\n\n\n"],"names":["constructor","canvasHandler","this","setupBrushSize","brushSizeInput","document","getElementById","addEventListener","updateBrushSize","currentBrushSize","setBrushStyling","color","arguments","length","undefined","colorHandler","currentColor","brushSize","ctx","lineCap","lineWidth","strokeStyle","parseInt","value","setupColorHandling","brushColorPicker","bgColorPicker","drawnPaths","redoStack","clear","forEach","path","redrawPath","canvas","style","backgroundColor","setupDrawingEventListeners","e","startDrawing","draw","stopDrawing","isDrawing","currentPath","canvasMouseX","clientX","offsetLeft","canvasMouseY","clientY","offsetTop","beginPath","moveTo","push","x","y","brushHandler","mouseX","mouseY","lineTo","eraserCheckbox","checked","stroke","isErase","setupDownloadBtn","downloadBtn","download","tempCanvas","createElement","tempCtx","getContext","width","height","fillStyle","fillRect","drawImage","dataUrl","toDataURL","link","href","click","setupCanvas","setupCanvasProportions","setupEraser","setupUndoBtn","setupRedoBtn","setupClearBtn","drawingHandler","DrawingHandler","ColorHandler","BrushHandler","downloadHandler","DownloadHandler","position","top","topMargin","window","innerHeight","innerWidth","clearBtn","undoBtn","undo","redoBtn","redo","clearRect","undonePath","pop","point","idx","redonePath","brushRadio","eraserRadio","brushLabel","querySelector","eraserLabel","detectChange","updateIcon","src","radio","CanvasHandler","ToolIcon"],"sourceRoot":""}