{"version":3,"file":"main.js","mappings":"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","sources":["webpack://canvas-project/./src/scripts/canvas.js","webpack://canvas-project/./src/index.js"],"sourcesContent":["class Canvas {\n  constructor() {\n    this.setupCanvas();\n    this.setupCanvasProportions();\n    this.setupDrawingEventListeners();\n    this.setupColorHandeling();\n    this.setupUndoBtn();\n    this.setupRedoBtn();\n    this.setupClearBtn();\n  }\n\n  // setting up the canvas\n  setupCanvas() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.isDrawing = false;\n  }\n\n  setupCanvasProportions() {\n    const topMargin = 100;\n    const bottomMargin = 100;\n\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.top = topMargin + \"px\";\n\n    this.canvas.height = window.innerHeight - topMargin - bottomMargin;\n    this.canvas.width = window.innerWidth;\n  }\n\n  setupDrawingEventListeners() {\n    this.canvas.addEventListener(\"mousedown\", this.startDrawing.bind(this));\n    this.canvas.addEventListener(\"mousemove\", this.draw.bind(this));\n    this.canvas.addEventListener(\"mouseup\", this.stopDrawing.bind(this));\n    this.canvas.addEventListener(\"mouseout\", this.stopDrawing.bind(this));\n  }\n\n  setupColorHandeling() {\n    // if a brush color has been selected..\n    this.colorBtns = document.querySelectorAll(\".color-btn\");\n    this.brushColorPicker = document.getElementById(\"color-picker\");\n\n    this.colorBtns.forEach((colorbtn) => {\n      colorbtn.addEventListener(\"click\", () => {\n        this.currentColor = colorbtn.style.backgroundColor;\n      });\n    });\n\n    this.brushColorPicker.addEventListener(\"input\", () => {\n      this.currentColor = this.brushColorPicker.value;\n    });\n\n    // if a bg color has been selected..\n    this.bgColorPicker = document.getElementById(\"background-color-picker\");\n    this.bgColorPicker.addEventListener(\n      \"input\",\n      () => (this.canvas.style.backgroundColor = this.bgColorPicker.value)\n    );\n  }\n\n  setupUndoBtn() {\n    this.drawnPaths = [];\n    this.undoBtn = document.getElementById(\"undo\");\n    this.undoBtn.addEventListener(\"click\", () => this.undo());\n  }\n\n  setupRedoBtn() {\n    this.redoStack = [];\n    this.redoBtn = document.getElementById(\"redo\");\n    this.redoBtn.addEventListener(\"click\", () => this.redo());\n  }\n\n  setupClearBtn() {\n    this.clearBtn = document.getElementById(\"clear\");\n    this.clearBtn.addEventListener(\"click\", () => this.clear());\n  }\n\n  // drawing actions\n  startDrawing(e) {\n    // clear the stack when a new drawing begins\n    if (!this.isDrawing) {\n      this.currentPath = [];\n    }\n\n    this.isDrawing = true;\n\n    // begin a new path in the canvas ctx & move to initial drawing pos\n    this.ctx.beginPath();\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const canvasMouseX = e.clientX - this.canvas.offsetLeft;\n    const canvasMouseY = e.clientY - this.canvas.offsetTop;\n\n    // move the brush to the adjusted mouse coordinates\n    this.ctx.moveTo(canvasMouseX, canvasMouseY);\n  }\n\n  draw(e) {\n    if (!this.isDrawing) return;\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const mouseX = e.clientX - this.canvas.offsetLeft;\n    const mouseY = e.clientY - this.canvas.offsetTop;\n\n    // connect the current drawing position to the new position\n    this.ctx.lineTo(mouseX, mouseY);\n\n    this.setBrushStyling();\n\n    // draw the line on the canvas\n    this.ctx.stroke();\n\n    // store the current point in the drawing path\n    this.currentPath.push({ x: mouseX, y: mouseY, color: this.currentColor });\n  }\n\n  stopDrawing() {\n    if (this.isDrawing) {\n      this.drawnPaths.push(this.currentPath); // if currently drawing, save the current path to the stack (for undo feature)\n      this.isDrawing = false;\n    }\n  }\n\n  setBrushStyling(color = this.currentColor) {\n    this.ctx.lineCap = \"round\";\n    this.ctx.lineWidth = 5;\n    this.ctx.strokeStyle = color;\n  }\n\n  // btn actions\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.style.backgroundColor = \"white\";\n    this.redoStack = [];\n    this.drawnPaths = [];\n  }\n\n  undo() {\n    // if there are paths in the stack\n    if (this.drawnPaths.length > 0) {\n      // clear the entire canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (undo) last drawn path from the stack\n      const undonePath = this.drawnPaths.pop();\n\n      // push the undone path to redo stack\n      this.redoStack.push(undonePath);\n\n      // redraw all paths with the correct color\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n\n      // return the undone path to be used in the redo method\n      return undonePath;\n    }\n\n    // if there are no paths to undo, return null \n    return null;\n  }\n\n  redrawPath(path, isUndo = true) {\n    path.forEach((point, idx) => {\n      // if it's the starting point of the path\n      if (idx === 0) {\n        // move to the starting point\n        this.ctx.beginPath();\n        this.ctx.moveTo(point.x, point.y);\n      } else {\n        // draw a line to the next point\n        this.ctx.lineTo(point.x, point.y);\n\n        this.setBrushStyling(isUndo ? point.color : this.currentColor);\n        this.ctx.stroke();\n      }\n    });\n  }\n\n  redo() {\n    // if there are paths in the redo stack\n    if (this.redoStack.length > 0) {\n      // clear the entire canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (redo) last undone path from the redo stack\n      const redonePath = this.redoStack.pop();\n\n      // push the redone path to drawnPaths stack\n      this.drawnPaths.push(redonePath);\n\n      // redraw all paths with the correct color\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n\n      // return the redone path to be used if needed\n      return redonePath;\n    }\n\n    // if there are no paths to redo, return null \n    return null;\n  }\n}\n\nexport default Canvas;\n","import Canvas from \"./scripts/canvas\";\nimport Brush from \"./scripts/brush\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new Canvas();\n});\n\n\n"],"names":["constructor","this","setupCanvas","setupCanvasProportions","setupDrawingEventListeners","setupColorHandeling","setupUndoBtn","setupRedoBtn","setupClearBtn","canvas","document","getElementById","ctx","getContext","isDrawing","style","position","top","topMargin","height","window","innerHeight","width","innerWidth","addEventListener","startDrawing","bind","draw","stopDrawing","colorBtns","querySelectorAll","brushColorPicker","forEach","colorbtn","currentColor","backgroundColor","value","bgColorPicker","drawnPaths","undoBtn","undo","redoStack","redoBtn","redo","clearBtn","clear","e","currentPath","beginPath","canvasMouseX","clientX","offsetLeft","canvasMouseY","clientY","offsetTop","moveTo","mouseX","mouseY","lineTo","setBrushStyling","stroke","push","x","y","color","arguments","length","undefined","lineCap","lineWidth","strokeStyle","clearRect","undonePath","pop","path","redrawPath","isUndo","point","idx","redonePath","Canvas"],"sourceRoot":""}