{"version":3,"file":"main.js","mappings":"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","sources":["webpack://canvas-project/./src/scripts/colorHandler.js","webpack://canvas-project/./src/scripts/drawingHandler.js","webpack://canvas-project/./src/scripts/canvas.js","webpack://canvas-project/./src/scripts/toolIcon.js","webpack://canvas-project/./src/index.js"],"sourcesContent":["class ColorHandler {\n  constructor(canvasHandler) {\n    this.setupColorHandling()\n    this.canvasHandler = canvasHandler\n  }\n\n  setupColorHandling() {\n    this.currentColor = \"black\";\n\n    // if a brush color has been selected..\n    this.colorBtns = document.querySelectorAll(\".color-btn\");\n    this.brushColorPicker = document.getElementById(\"color-picker\");\n\n    this.colorBtns.forEach((colorbtn) => {\n      colorbtn.addEventListener(\"click\", () => {\n        this.currentColor = colorbtn.style.backgroundColor;\n      });\n    });\n\n    this.brushColorPicker.addEventListener(\"input\", () => {\n      this.currentColor = this.brushColorPicker.value;\n    });\n\n    // if a bg color has been selected..\n    this.bgColorPicker = document.getElementById(\"background-color-picker\");\n    this.bgColorPicker.addEventListener(\n      \"input\",\n      () => {\n        const drawnPaths = this.canvasHandler.drawnPaths\n        const redoStack = this.canvasHandler.redoStack\n        this.canvasHandler.clear()\n        this.canvasHandler.drawnPaths = drawnPaths\n        this.canvasHandler.redoStack = redoStack\n        drawnPaths.forEach((path) => this.canvasHandler.redrawPath(path));\n        this.canvasHandler.canvas.style.backgroundColor = this.bgColorPicker.value;\n      }\n    );\n  }\n}\n\nexport default ColorHandler","class DrawingHandler {\n  constructor(canvasHandler, colorHandler) {\n    this.canvasHandler = canvasHandler\n    this.canvas = this.canvasHandler.canvas\n    this.colorHandler = colorHandler\n    this.setupDrawingEventListeners()\n  }\n\n  setupDrawingEventListeners() {\n    this.canvas.addEventListener(\"mousedown\", (e) => this.startDrawing(e));\n    this.canvas.addEventListener(\"mousemove\", (e) => this.draw(e));\n    this.canvas.addEventListener(\"mouseup\", () => this.stopDrawing());\n    this.canvas.addEventListener(\"mouseout\", () => this.stopDrawing());\n  }\n\n  // // drawing actions\n  startDrawing(e) {\n    if (!this.isDrawing) {\n      // clear the stacks when a new drawing begins\n      this.currentPath = [];\n      this.redoStack = [];\n      this.isDrawing = true;\n    }\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const canvasMouseX = e.clientX - this.canvas.offsetLeft;\n    const canvasMouseY = e.clientY - this.canvas.offsetTop;\n\n    // begin a new path in the canvas ctx & move to initial drawing pos\n    this.canvasHandler.ctx.beginPath();\n\n    // move the brush to the adjusted mouse coordinates\n    this.canvasHandler.ctx.moveTo(canvasMouseX, canvasMouseY);\n\n    // store the starting point in the drawing path\n    this.currentPath.push({\n      x: canvasMouseX,\n      y: canvasMouseY,\n      color: this.colorHandler.currentColor,\n      brushSize: this.canvasHandler.currentBrushSize,\n    });\n\n    // draw a dot at the starting point\n    this.draw(e);\n  }\n\n  draw(e) {\n    if (!this.isDrawing) return;\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const mouseX = e.clientX - this.canvas.offsetLeft;\n    const mouseY = e.clientY - this.canvas.offsetTop;\n\n    // connect the current drawing position to the new position\n    this.canvasHandler.ctx.lineTo(mouseX, mouseY);\n\n    // Set brush styling based on whether eraser or brush is checked\n    const color = this.canvasHandler.eraserCheckbox.checked\n      ? this.colorHandler.bgColorPicker.value\n      : this.colorHandler.currentColor;\n\n    this.canvasHandler.setBrushStyling(color, this.canvasHandler.currentBrushSize);\n\n    // draw the line on the canvas\n    this.canvasHandler.ctx.stroke();\n\n    // store the current point in the drawing path\n    this.currentPath.push({\n      x: mouseX,\n      y: mouseY,\n      color: color,\n      brushSize: this.canvasHandler.currentBrushSize,\n    });\n  }\n\n  stopDrawing() {\n    if (this.canvasHandler.eraserCheckbox.checked) this.currentPath.isErase = true;\n    if (this.isDrawing) {\n      this.canvasHandler.drawnPaths.push(this.currentPath); // if currently drawing, save the current path to the stack (for undo feature)\n      this.isDrawing = false;\n    }\n  }\n}\n\nexport default DrawingHandler","import ColorHandler from \"./colorHandler\"; \nimport DrawingHandler from \"./drawingHandler\";\n\nclass Canvas {\n  constructor() {\n    this.setupCanvas();\n    this.setupCanvasProportions();\n    this.setupBrushSize();\n    this.setupEraser();\n    this.setupUndoBtn();\n    this.setupRedoBtn();\n    this.setupClearBtn();\n\n    this.colorHandler = new ColorHandler(this)\n    this.drawingHandler = new DrawingHandler(this, this.colorHandler)\n  }\n\n  // setting up the canvas\n  setupCanvas() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.isDrawing = false;\n  }\n\n  setupCanvasProportions() {\n    const topMargin = 100;\n    const bottomMargin = 100;\n\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.top = topMargin + \"px\";\n\n    this.canvas.height = window.innerHeight - topMargin - bottomMargin;\n    this.canvas.width = window.innerWidth;\n  }\n\n  setupBrushSize() {\n    this.brushSizeInput = document.getElementById(\"size-slider\");\n    this.brushSizeInput.addEventListener(\"input\", () => this.updateBrushSize());\n    this.currentBrushSize = 5;\n  }\n\n  setupClearBtn() {\n    this.clearBtn = document.getElementById(\"clear\");\n    this.clearBtn.addEventListener(\"click\", () => this.clear());\n  }\n\n  setupEraser() {\n    this.eraserCheckbox = document.getElementById(\"eraser\");\n  }\n\n  setupUndoBtn() {\n    this.drawnPaths = [];\n    this.undoBtn = document.getElementById(\"undo\");\n    this.undoBtn.addEventListener(\"click\", () => this.undo());\n  }\n\n  setupRedoBtn() {\n    this.redoStack = [];\n    this.redoBtn = document.getElementById(\"redo\");\n    this.redoBtn.addEventListener(\"click\", () => this.redo());\n  }\n\n  setBrushStyling(\n    color = this.currentColor,\n    brushSize = this.currentBrushSize\n  ) {\n    this.ctx.lineCap = \"round\";\n    this.ctx.lineWidth = brushSize;\n    this.ctx.strokeStyle = color;\n  }\n\n  updateBrushSize() {\n    this.currentBrushSize = parseInt(this.brushSizeInput.value);\n    this.setBrushStyling();\n  }\n\n  // btn actions\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.style.backgroundColor = \"white\";\n    this.redoStack = [];\n    this.drawnPaths = [];\n  }\n\n  undo() {\n    // if there are paths in the stack\n    if (this.drawnPaths.length > 0) {\n      // clear canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (undo) last drawn path from the stack\n      const undonePath = this.drawnPaths.pop();\n      // push the undone path to redo stack\n      this.drawingHandler.redoStack.push(undonePath);\n\n      // redraw all paths that are still in the stack\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n    }\n  }\n\n  redrawPath(path) {\n    path.forEach((point, idx) => {\n      // if it's the starting point of the path\n      if (idx === 0) {\n        // move to the starting point\n        this.ctx.beginPath();\n        this.ctx.moveTo(point.x, point.y);\n      } else {\n        // draw a line to the next point\n        this.ctx.lineTo(point.x, point.y);\n\n        // set brush styling based on point clr & brush size\n        if (path.isErase) point.color = this.colorHandler.bgColorPicker.value\n        this.setBrushStyling(point.color, point.brushSize);\n\n        this.ctx.stroke();\n      }\n    });\n  }\n\n  redo() {\n    // if there are paths in the redo stack\n    if (this.drawingHandler.redoStack.length > 0) {\n      // clear canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (redo) last undone path from the redo stack\n      const redonePath = this.drawingHandler.redoStack.pop();\n      debugger\n      // push the redone path to drawnPaths stack\n      this.drawnPaths.push(redonePath);\n\n      // redraw all paths with the correct color\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n    }\n  }\n}\n\nexport default Canvas;\n","class ToolIcon {\n  constructor() {\n    this.brushRadio = document.getElementById(\"brush\");\n    this.eraserRadio = document.getElementById(\"eraser\");\n    this.brushLabel = document.querySelector('label[for=\"brush\"]');\n    this.eraserLabel = document.querySelector('label[for=\"eraser\"]');\n    this.detectChange();\n    this.updateIcon();\n  }\n\n  updateIcon() {\n    // update brush icon based on whether the brush is checked\n    this.brushLabel.querySelector(\"img\").src = this.brushRadio.checked\n      ? \"assets/tab-icon.png\"\n      : \"assets/menu icons/not-active-brush.png\";\n\n    // update eraser icon based on whether the eraser is checked\n    this.eraserLabel.querySelector(\"img\").src = this.eraserRadio.checked\n      ? \"assets/menu icons/active-eraser.png\"\n      : \"assets/menu icons/not-active-eraser.png\";\n  }\n\n  detectChange() {\n    // update icon clr when tool is changed\n    [this.brushRadio, this.eraserRadio].forEach((radio) => {\n      radio.addEventListener(\"change\", () => this.updateIcon());\n    });\n  }\n}\n\nexport default ToolIcon;\n","import Canvas from \"./scripts/canvas\";\nimport ToolIcon from \"./scripts/toolIcon\";\nimport BrushHandler from \"./scripts/brushHandler\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new Canvas();\n  new ToolIcon();\n});\n"],"names":["constructor","canvasHandler","this","setupColorHandling","currentColor","colorBtns","document","querySelectorAll","brushColorPicker","getElementById","forEach","colorbtn","addEventListener","style","backgroundColor","value","bgColorPicker","drawnPaths","redoStack","clear","path","redrawPath","canvas","colorHandler","setupDrawingEventListeners","e","startDrawing","draw","stopDrawing","isDrawing","currentPath","canvasMouseX","clientX","offsetLeft","canvasMouseY","clientY","offsetTop","ctx","beginPath","moveTo","push","x","y","color","brushSize","currentBrushSize","mouseX","mouseY","lineTo","eraserCheckbox","checked","setBrushStyling","stroke","isErase","setupCanvas","setupCanvasProportions","setupBrushSize","setupEraser","setupUndoBtn","setupRedoBtn","setupClearBtn","ColorHandler","drawingHandler","DrawingHandler","getContext","position","top","topMargin","height","window","innerHeight","width","innerWidth","brushSizeInput","updateBrushSize","clearBtn","undoBtn","undo","redoBtn","redo","arguments","length","undefined","lineCap","lineWidth","strokeStyle","parseInt","clearRect","undonePath","pop","point","idx","redonePath","brushRadio","eraserRadio","brushLabel","querySelector","eraserLabel","detectChange","updateIcon","src","radio","Canvas","ToolIcon"],"sourceRoot":""}