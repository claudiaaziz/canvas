{"version":3,"file":"main.js","mappings":"6BAiPA,IAjPA,MACEA,WAAAA,GACEC,KAAKC,cACLD,KAAKE,yBACLF,KAAKG,6BACLH,KAAKI,iBACLJ,KAAKK,qBACLL,KAAKM,cACLN,KAAKO,eACLP,KAAKQ,eACLR,KAAKS,eACP,CAGAR,WAAAA,GACED,KAAKU,OAASC,SAASC,eAAe,UACtCZ,KAAKa,IAAMb,KAAKU,OAAOI,WAAW,MAClCd,KAAKe,WAAY,CACnB,CAEAb,sBAAAA,GAIEF,KAAKU,OAAOM,MAAMC,SAAW,WAC7BjB,KAAKU,OAAOM,MAAME,IAAMC,QAExBnB,KAAKU,OAAOU,OAASC,OAAOC,YANV,IACG,IAMrBtB,KAAKU,OAAOa,MAAQF,OAAOG,UAC7B,CAEArB,0BAAAA,GACEH,KAAKU,OAAOe,iBAAiB,aAAcC,GAAM1B,KAAK2B,aAAaD,KACnE1B,KAAKU,OAAOe,iBAAiB,aAAcC,GAAM1B,KAAK4B,KAAKF,KAC3D1B,KAAKU,OAAOe,iBAAiB,WAAW,IAAMzB,KAAK6B,gBACnD7B,KAAKU,OAAOe,iBAAiB,YAAY,IAAMzB,KAAK6B,eACtD,CAEAzB,cAAAA,GACEJ,KAAK8B,eAAiBnB,SAASC,eAAe,eAC9CZ,KAAK8B,eAAeL,iBAAiB,SAAS,IAAMzB,KAAK+B,oBACzD/B,KAAKgC,iBAAmB,CAC1B,CAEA3B,kBAAAA,GAEEL,KAAKiC,UAAYtB,SAASuB,iBAAiB,cAC3ClC,KAAKmC,iBAAmBxB,SAASC,eAAe,gBAEhDZ,KAAKiC,UAAUG,SAASC,IACtBA,EAASZ,iBAAiB,SAAS,KACjCzB,KAAKsC,aAAeD,EAASrB,MAAMuB,eAAe,GAClD,IAGJvC,KAAKmC,iBAAiBV,iBAAiB,SAAS,KAC9CzB,KAAKsC,aAAetC,KAAKmC,iBAAiBK,KAAK,IAIjDxC,KAAKyC,cAAgB9B,SAASC,eAAe,2BAC7CZ,KAAKyC,cAAchB,iBACjB,SACA,IAAOzB,KAAKU,OAAOM,MAAMuB,gBAAkBvC,KAAKyC,cAAcD,OAElE,CAEA/B,aAAAA,GACET,KAAK0C,SAAW/B,SAASC,eAAe,SACxCZ,KAAK0C,SAASjB,iBAAiB,SAAS,IAAMzB,KAAK2C,SACrD,CAEArC,WAAAA,GACEN,KAAK4C,eAAiBjC,SAASC,eAAe,UAC9CZ,KAAK4C,eAAenB,iBAAiB,UAAU,IAAMzB,KAAK6C,SAC5D,CAEAtC,YAAAA,GACEP,KAAK8C,WAAa,GAClB9C,KAAK+C,QAAUpC,SAASC,eAAe,QACvCZ,KAAK+C,QAAQtB,iBAAiB,SAAS,IAAMzB,KAAKgD,QACpD,CAEAxC,YAAAA,GACER,KAAKiD,UAAY,GACjBjD,KAAKkD,QAAUvC,SAASC,eAAe,QACvCZ,KAAKkD,QAAQzB,iBAAiB,SAAS,IAAMzB,KAAKmD,QACpD,CAGAxB,YAAAA,CAAaD,GACN1B,KAAKe,YAERf,KAAKoD,YAAc,GACnBpD,KAAKiD,UAAY,GACjBjD,KAAKe,WAAY,GAInB,MAAMsC,EAAe3B,EAAE4B,QAAUtD,KAAKU,OAAO6C,WACvCC,EAAe9B,EAAE+B,QAAUzD,KAAKU,OAAOgD,UAG7C1D,KAAKa,IAAI8C,YAGT3D,KAAKa,IAAI+C,OAAOP,EAAcG,GAG9BxD,KAAKoD,YAAYS,KAAK,CACpBC,EAAGT,EACHU,EAAGP,EACHQ,MAAOhE,KAAKsC,aACZ2B,UAAWjE,KAAKgC,mBAIlBhC,KAAK4B,KAAKF,EACZ,CAEAE,IAAAA,CAAKF,GACH,IAAK1B,KAAKe,UAAW,OAGrB,MAAMmD,EAASxC,EAAE4B,QAAUtD,KAAKU,OAAO6C,WACjCY,EAASzC,EAAE+B,QAAUzD,KAAKU,OAAOgD,UAGvC1D,KAAKa,IAAIuD,OAAOF,EAAQC,GAGxB,MAAME,EAAcrE,KAAK4C,eAAe0B,QACpCtE,KAAKyC,cAAcD,MACnBxC,KAAKsC,aAETtC,KAAKuE,gBAAgBF,EAAarE,KAAKgC,kBAGvChC,KAAKa,IAAI2D,SAGTxE,KAAKoD,YAAYS,KAAK,CACpBC,EAAGI,EACHH,EAAGI,EACHH,MAAOK,EACPJ,UAAWjE,KAAKgC,kBAEpB,CAEAH,WAAAA,GACM7B,KAAKe,YACPf,KAAK8C,WAAWe,KAAK7D,KAAKoD,aAC1BpD,KAAKe,WAAY,EAErB,CAEAwD,eAAAA,GAGE,IAFAP,EAAKS,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAGzE,KAAKsC,aACb2B,EAASQ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAGzE,KAAKgC,iBAEjBhC,KAAKa,IAAI+D,QAAU,QACnB5E,KAAKa,IAAIgE,UAAYZ,EACrBjE,KAAKa,IAAIiE,YAAcd,CACzB,CAEAjC,eAAAA,GACE/B,KAAKgC,iBAAmB+C,SAAS/E,KAAK8B,eAAeU,OACrDxC,KAAKuE,iBACP,CAGA5B,KAAAA,GACE3C,KAAKa,IAAImE,UAAU,EAAG,EAAGhF,KAAKU,OAAOa,MAAOvB,KAAKU,OAAOU,QACxDpB,KAAKU,OAAOM,MAAMuB,gBAAkB,QACpCvC,KAAKiD,UAAY,GACjBjD,KAAK8C,WAAa,EACpB,CAEAD,KAAAA,GACM7C,KAAK4C,eAAe0B,UAEtBtE,KAAKsC,aAAetC,KAAKyC,cAAcD,MAE3C,CAEAQ,IAAAA,GAEE,GAAIhD,KAAK8C,WAAW4B,OAAS,EAAG,CAE9B1E,KAAKa,IAAImE,UAAU,EAAG,EAAGhF,KAAKU,OAAOa,MAAOvB,KAAKU,OAAOU,QAGxD,MAAM6D,EAAajF,KAAK8C,WAAWoC,MAEnClF,KAAKiD,UAAUY,KAAKoB,GAGpBjF,KAAK8C,WAAWV,SAAS+C,GAASnF,KAAKoF,WAAWD,IACpD,CACF,CAEAC,UAAAA,CAAWD,GAAqB,IAAfE,IAAMZ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACrBU,EAAK/C,SAAQ,CAACkD,EAAOC,KAEP,IAARA,GAEFvF,KAAKa,IAAI8C,YACT3D,KAAKa,IAAI+C,OAAO0B,EAAMxB,EAAGwB,EAAMvB,KAG/B/D,KAAKa,IAAIuD,OAAOkB,EAAMxB,EAAGwB,EAAMvB,GAG/B/D,KAAKuE,gBACHc,EAASC,EAAMtB,MAAQhE,KAAKsC,aAC5BgD,EAAMrB,WAGRjE,KAAKa,IAAI2D,SACX,GAEJ,CAEArB,IAAAA,GAEE,GAAInD,KAAKiD,UAAUyB,OAAS,EAAG,CAE7B1E,KAAKa,IAAImE,UAAU,EAAG,EAAGhF,KAAKU,OAAOa,MAAOvB,KAAKU,OAAOU,QAGxD,MAAMoE,EAAaxF,KAAKiD,UAAUiC,MAGlClF,KAAK8C,WAAWe,KAAK2B,GAGrBxF,KAAK8C,WAAWV,SAAS+C,GAASnF,KAAKoF,WAAWD,IACpD,CACF,GC3OFxE,SAASc,iBAAiB,oBAAoB,KAC5C,IAAIgE,CAAQ,G","sources":["webpack://canvas-project/./src/scripts/canvas.js","webpack://canvas-project/./src/index.js"],"sourcesContent":["class Canvas {\n  constructor() {\n    this.setupCanvas();\n    this.setupCanvasProportions();\n    this.setupDrawingEventListeners();\n    this.setupBrushSize();\n    this.setupColorHandling();\n    this.setupEraser();\n    this.setupUndoBtn();\n    this.setupRedoBtn();\n    this.setupClearBtn();\n  }\n\n  // setting up the canvas\n  setupCanvas() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.isDrawing = false;\n  }\n\n  setupCanvasProportions() {\n    const topMargin = 100;\n    const bottomMargin = 100;\n\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.top = topMargin + \"px\";\n\n    this.canvas.height = window.innerHeight - topMargin - bottomMargin;\n    this.canvas.width = window.innerWidth;\n  }\n\n  setupDrawingEventListeners() {\n    this.canvas.addEventListener(\"mousedown\", (e) => this.startDrawing(e));\n    this.canvas.addEventListener(\"mousemove\", (e) => this.draw(e));\n    this.canvas.addEventListener(\"mouseup\", () => this.stopDrawing());\n    this.canvas.addEventListener(\"mouseout\", () => this.stopDrawing());\n  }\n\n  setupBrushSize() {\n    this.brushSizeInput = document.getElementById(\"size-slider\");\n    this.brushSizeInput.addEventListener(\"input\", () => this.updateBrushSize());\n    this.currentBrushSize = 5;\n  }\n\n  setupColorHandling() {\n    // if a brush color has been selected..\n    this.colorBtns = document.querySelectorAll(\".color-btn\");\n    this.brushColorPicker = document.getElementById(\"color-picker\");\n\n    this.colorBtns.forEach((colorbtn) => {\n      colorbtn.addEventListener(\"click\", () => {\n        this.currentColor = colorbtn.style.backgroundColor;\n      });\n    });\n\n    this.brushColorPicker.addEventListener(\"input\", () => {\n      this.currentColor = this.brushColorPicker.value;\n    });\n\n    // if a bg color has been selected..\n    this.bgColorPicker = document.getElementById(\"background-color-picker\");\n    this.bgColorPicker.addEventListener(\n      \"input\",\n      () => (this.canvas.style.backgroundColor = this.bgColorPicker.value)\n    );\n  }\n\n  setupClearBtn() {\n    this.clearBtn = document.getElementById(\"clear\");\n    this.clearBtn.addEventListener(\"click\", () => this.clear());\n  }\n\n  setupEraser() {\n    this.eraserCheckbox = document.getElementById(\"eraser\");\n    this.eraserCheckbox.addEventListener(\"change\", () => this.erase());\n  }\n\n  setupUndoBtn() {\n    this.drawnPaths = [];\n    this.undoBtn = document.getElementById(\"undo\");\n    this.undoBtn.addEventListener(\"click\", () => this.undo());\n  }\n\n  setupRedoBtn() {\n    this.redoStack = [];\n    this.redoBtn = document.getElementById(\"redo\");\n    this.redoBtn.addEventListener(\"click\", () => this.redo());\n  }\n\n  // // drawing actions\n  startDrawing(e) {\n    if (!this.isDrawing) {\n      // clear the stacks when a new drawing begins\n      this.currentPath = [];\n      this.redoStack = [];\n      this.isDrawing = true;\n    }\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const canvasMouseX = e.clientX - this.canvas.offsetLeft;\n    const canvasMouseY = e.clientY - this.canvas.offsetTop;\n\n    // begin a new path in the canvas ctx & move to initial drawing pos\n    this.ctx.beginPath();\n\n    // move the brush to the adjusted mouse coordinates\n    this.ctx.moveTo(canvasMouseX, canvasMouseY);\n\n    // store the starting point in the drawing path\n    this.currentPath.push({\n      x: canvasMouseX,\n      y: canvasMouseY,\n      color: this.currentColor,\n      brushSize: this.currentBrushSize,\n    });\n\n    // draw a dot at the starting point\n    this.draw(e);\n  }\n\n  draw(e) {\n    if (!this.isDrawing) return;\n\n    // calculate the adjusted mouse coordinates relative to the canvas\n    const mouseX = e.clientX - this.canvas.offsetLeft;\n    const mouseY = e.clientY - this.canvas.offsetTop;\n\n    // connect the current drawing position to the new position\n    this.ctx.lineTo(mouseX, mouseY);\n\n    // Set brush styling based on whether eraser is active\n    const eraserColor = this.eraserCheckbox.checked\n      ? this.bgColorPicker.value\n      : this.currentColor;\n\n    this.setBrushStyling(eraserColor, this.currentBrushSize);\n\n    // draw the line on the canvas\n    this.ctx.stroke();\n\n    // store the current point in the drawing path\n    this.currentPath.push({\n      x: mouseX,\n      y: mouseY,\n      color: eraserColor,\n      brushSize: this.currentBrushSize,\n    });\n  }\n\n  stopDrawing() {\n    if (this.isDrawing) {\n      this.drawnPaths.push(this.currentPath); // if currently drawing, save the current path to the stack (for undo feature)\n      this.isDrawing = false;\n    }\n  }\n\n  setBrushStyling(\n    color = this.currentColor,\n    brushSize = this.currentBrushSize\n  ) {\n    this.ctx.lineCap = \"round\";\n    this.ctx.lineWidth = brushSize;\n    this.ctx.strokeStyle = color;\n  }\n\n  updateBrushSize() {\n    this.currentBrushSize = parseInt(this.brushSizeInput.value);\n    this.setBrushStyling();\n  }\n\n  // btn actions\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.style.backgroundColor = \"white\";\n    this.redoStack = [];\n    this.drawnPaths = [];\n  }\n\n  erase() {\n    if (this.eraserCheckbox.checked) {\n      // If eraser is selected, set color to background\n      this.currentColor = this.bgColorPicker.value;\n    }\n  }\n\n  undo() {\n    // if there are paths in the stack\n    if (this.drawnPaths.length > 0) {\n      // clear canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (undo) last drawn path from the stack\n      const undonePath = this.drawnPaths.pop();\n      // push the undone path to redo stack\n      this.redoStack.push(undonePath);\n\n      // redraw all paths that are still in the stack with the correct color\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n    }\n  }\n\n  redrawPath(path, isUndo = true) {\n    path.forEach((point, idx) => {\n      // if it's the starting point of the path\n      if (idx === 0) {\n        // move to the starting point\n        this.ctx.beginPath();\n        this.ctx.moveTo(point.x, point.y);\n      } else {\n        // draw a line to the next point\n        this.ctx.lineTo(point.x, point.y);\n\n        // set brush styling color based on whether it's an undo or not\n        this.setBrushStyling(\n          isUndo ? point.color : this.currentColor,\n          point.brushSize\n        );\n\n        this.ctx.stroke();\n      }\n    });\n  }\n\n  redo() {\n    // if there are paths in the redo stack\n    if (this.redoStack.length > 0) {\n      // clear canvas (to prep for redraw)\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // remove (redo) last undone path from the redo stack\n      const redonePath = this.redoStack.pop();\n\n      // push the redone path to drawnPaths stack\n      this.drawnPaths.push(redonePath);\n\n      // redraw all paths with the correct color\n      this.drawnPaths.forEach((path) => this.redrawPath(path));\n    }\n  }\n}\n\nexport default Canvas;\n","import Canvas from \"./scripts/canvas\";\nimport Brush from \"./scripts/brush\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new Canvas();\n});\n\n\n"],"names":["constructor","this","setupCanvas","setupCanvasProportions","setupDrawingEventListeners","setupBrushSize","setupColorHandling","setupEraser","setupUndoBtn","setupRedoBtn","setupClearBtn","canvas","document","getElementById","ctx","getContext","isDrawing","style","position","top","topMargin","height","window","innerHeight","width","innerWidth","addEventListener","e","startDrawing","draw","stopDrawing","brushSizeInput","updateBrushSize","currentBrushSize","colorBtns","querySelectorAll","brushColorPicker","forEach","colorbtn","currentColor","backgroundColor","value","bgColorPicker","clearBtn","clear","eraserCheckbox","erase","drawnPaths","undoBtn","undo","redoStack","redoBtn","redo","currentPath","canvasMouseX","clientX","offsetLeft","canvasMouseY","clientY","offsetTop","beginPath","moveTo","push","x","y","color","brushSize","mouseX","mouseY","lineTo","eraserColor","checked","setBrushStyling","stroke","arguments","length","undefined","lineCap","lineWidth","strokeStyle","parseInt","clearRect","undonePath","pop","path","redrawPath","isUndo","point","idx","redonePath","Canvas"],"sourceRoot":""}